## Абстракция

Одна из основных целей использования абстракции в ООП – повышение гибкости и упрощение разработки. Абстрактный подход помогает создавать интерфейсы и классы, которые определяют только те свойства и методы, которые необходимы для выполнения определенной задачи. Это позволяет создавать более гибкие и масштабируемые приложения, которые легко поддаются изменению и расширению.

Предположим, что нам нужно написать программу, которая работает с графическими объектами разных типов. Для решения этой задачи удобно создать абстрактный класс **Shape** (фигура), определяющий абстрактные методы, которые могут быть использованы для работы с любой фигурой. Затем мы можем создать конкретные классы для конкретных типов фигур – окружность, квадрат, треугольник и т.д., которые расширяют базовый класс Shape. При этом мы можем использовать только те свойства и методы, которые необходимы для выполнения конкретной задачи, игнорируя детали реализации, которые не имеют значения в данном контексте.

Абстрактный подход помогает эффективно решать ряд сложных задач:

- Позволяет выделять существенные характеристики объекта, игнорируя все незначительные детали.
- Принуждает подклассы к реализации конкретных методов или к выполнению определенных требований путем определения абстрактных методов или свойств. Таким образом, абстракция позволяет определять общие интерфейсы для классов, но при этом гарантирует, что каждый подкласс будет реализовывать свою версию этих методов или свойств.  
    
- Позволяет создавать общие модели объектов, которые могут использоваться для создания конкретных объектов.
- Упрощает работу со сложными системами, которые включают множество взаимодействующих компонентов, и позволяет создавать расширяемые, модульные приложения.  
    

## Абстрактные классы в Python

Для работы с абстрактными классами в Python используют модуль **abc**. Он предоставляет:

- **abc.ABC** – базовый класс для создания абстрактных классов. Абстрактный класс содержит один или несколько абстрактных методов, то есть методов без определения (пустых, без кода). Эти методы необходимо переопределить в подклассах.
- **abc.abstractmethod** – декоратор, который указывает, что метод является абстрактным. Этот декоратор применяется к методу внутри абстрактного класса. Класс, который наследует свойства и методы от абстрактного класса, должен реализовать все абстрактные методы, иначе он также будет считаться абстрактным.  
    

Рассмотрим пример абстрактного класса **Book**:

        `from abc import ABC, abstractmethod  class Book(ABC):     def __init__(self, title, author):         self.title = title         self.author = author      @abstractmethod     def get_summary(self):         pass  class Fiction(Book):     def get_summary(self):         print(f'"{self.title}" - роман в стиле исторический фикшн, автор - {self.author}')  class NonFiction(Book):     def get_summary(self):         print(f'"{self.title}" - книга в стиле нон фикшн, автор - {self.author}')  class Poetry(Book):     pass`
    

Класс **Book** имеет абстрактный метод **get_summary()**. Два подкласса Book (**Fiction** и **NonFiction**) реализуют метод **get_summary()**, а третий подкласс **Poetry** – нет. Когда мы создаем экземпляры Fiction и NonFiction и вызываем их методы get_summary(), получаем ожидаемый результат:

        `fiction_book = Fiction("Террор", "Дэн Симмонс") nonfiction_book = NonFiction("Как писать книги", "Стивен Кинг") fiction_book.get_summary() nonfiction_book.get_summary()`
    

Вывод:

        `"Террор" - роман в стиле исторический фикшн, автор - Дэн Симмонс "Как писать книги" - книга в стиле нон фикшн, автор - Стивен Кинг`
    

А вот вызов **Poetry** приведет к ошибке, поскольку в этом подклассе метод **get_summary()** не реализован:

        `poetry_book = Poetry("Стихотворения", "Борис Пастернак")`

    

Вывод:

        `TypeError: Can't instantiate abstract class Poetry with abstract methods get_summary`
    

Приведенный выше пример показывает, что семейство родственных классов (**Fiction** и **NonFiction** в нашем случае) может иметь общий интерфейс (метод **get_summary()**), но реализация этого интерфейса может быть разной. Мы также убедились, что любой подкласс **Book** должен реализовать метод **get_summary()**, чтобы обеспечить согласованную, безошибочную работу приложения.

Теперь рассмотрим чуть более сложный пример, который продемонстрирует, как можно комбинировать абстракцию с другими концепциями ООП. Определим абстрактный класс **Recipe** (рецепт), который имеет абстрактный метод **cook()**. Затем создадим три подкласса **Entree**, **Dessert** и **Appetizer** (основное блюдо, десерт и закуска). **Entree** и **Dessert** имеют свои собственные методы **cook()**, в отличие от **Appetizer** и **PartyMix**. **PartyMix** (орешки, чипсы, крекеры) является подклассом **Appetizer** и имеет свою реализацию **cook()**:

        `from abc import ABC, abstractmethod  class Recipe(ABC):     @abstractmethod     def cook(self):         pass  class Entree(Recipe):     def __init__(self, ingredients):         self.ingredients = ingredients      def cook(self):         print(f"Готовим на медленном огне смесь ингредиентов ({', '.join(self.ingredients)}) для основного блюда")  class Dessert(Recipe):     def __init__(self, ingredients):         self.ingredients = ingredients      def cook(self):         print(f"Смешиваем {', '.join(self.ingredients)} для десерта")  class Appetizer(Recipe):     pass  class PartyMix(Appetizer):     def cook(self):         print("Готовим снеки - выкладываем на поднос орешки, чипсы и крекеры")`
    

В этом примере наряду с абстракцией используются концепции полиморфизма и наследования.

Наследование заключается в том, что подклассы Entree, Dessert и PartyMix наследуют абстрактный метод cook() от абстрактного базового класса Recipe. Это означает, что все они имеют ту же сигнатуру (название и параметры) метода cook(), что и абстрактный метод, определенный в классе Recipe.

Полиморфизм проявляется в том, что каждый подкласс класса Recipe реализует метод cook() по-разному. Например, Entree реализует cook() для вывода инструкций по приготовлению основного блюда на медленном огне, а Dessert реализует cook() для вывода инструкций по смешиванию ингредиентов десерта. Эта разница в реализации является примером полиморфизма, когда различные объекты могут рассматриваться как объекты, которые относятся к одному типу, но при этом ведут себя по-разному:

        `entree = Entree(["курица", "рис", "овощи"]) dessert = Dessert(["мороженое", "шоколадные чипсы", "мараскиновые вишни"]) partymix = PartyMix() entree.cook()  dessert.cook() partymix.cook()`
    

Результат:

        `Готовим на медленном огне смесь ингредиентов (курица, рис, овощи) для основного блюда Смешиваем мороженое, шоколадные чипсы, мараскиновые вишни для десерта Готовим снеки - выкладываем на поднос орешки, чипсы и крекеры`
    

Вызов метода cook() для подкласса Appetizer приведет к ожидаемой ошибке:

        `appetizer = Appetizer() appetizer.cook()`
    

Результат:

        `TypeError: Can't instantiate abstract class Appetizer with abstract methods cook`
    
