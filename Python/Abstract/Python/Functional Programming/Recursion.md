## Принцип работы рекурсии

Рекурсивные функции состоят из двух частей: базового случая и рекурсивного случая. Базовый случай — это условие, при котором функция прекращает вызывать саму себя и возвращает результат. Рекурсивный случай — это условие, при котором функция вызывает саму себя для решения меньшей подзадачи.

### Пример рекурсии: вычисление факториала

Факториал числа `n` (`n!`) — это произведение всех натуральных чисел от 1 до `n`. Например, `5! = 5 * 4 * 3 * 2 * 1 = 120`. Факториал можно выразить через рекурсию следующим образом:

1. Базовый случай: если `n` равно 1, то `n! = 1`
2. Рекурсивный случай: если `n` больше 1, то `n! = n * (n-1)!`

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5|`def` `factorial(n):`<br><br>    `if` `n` `=``=` `1``:`<br><br>        `return` `1`<br><br>    `else``:`<br><br>        `return` `n` `*` `factorial(n``-``1``)`|

Запустить

## Проблемы с рекурсией и их решение

Рекурсия может привести к проблемам с памятью и производительностью, поскольку каждый вызов рекурсивной функции добавляет новый уровень в стек вызовов. Если рекурсия слишком глубокая, то может возникнуть ошибка переполнения стека.

Для решения этой проблемы можно использовать технику «мемоизации» — сохранение результатов рекурсивных вызовов в словаре и повторное использование их при необходимости. Это позволяет избежать повторных вычислений и ускорить выполнение рекурсивных функций.

|                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| --------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14 | `def` `memoize(f):`<br><br>    `cache` `=` `{}`<br><br>    `def` `memoized_function(``*``args):`<br><br>        `if` `args` `not` `in` `cache:`<br><br>            `cache[args]` `=` `f(``*``args)`<br><br>        `return` `cache[args]`<br><br>    `return` `memoized_function`<br><br>`@memoize`<br><br>`def` `factorial(n):`<br><br>    `if` `n` `=``=` `1``:`<br><br>        `return` `1`<br><br>    `else``:`<br><br>        `return` `n` `*` `factorial(n``-``1``)` |
## Когда использовать рекурсию

Рекурсия является удобным инструментом для решения задач, которые могут быть разложены на меньшие подзадачи. Такие задачи включают в себя обход деревьев, графов, вычисление чисел Фибоначчи, факториалов и др.

Однако следует помнить о возможных проблемах с памятью и производительностью, и использовать рекурсию с умом. В некоторых случаях, итеративные решения могут быть более эффективными и простыми для понимания.

**Рекурсивная функция** – это функция, которая вызывает сама себя, и при каждом очередном вызове использует данные, созданные во время предыдущего вызова. В программировании есть ряд задач, которые проще (но не всегда эффективнее) решаются с помощью рекурсии. Написание рекурсивных функций часто ставит начинающих программистов в тупик. Чтобы разобраться в принципе работы рекурсивных функций, нужно понять (в самых общих чертах) концепцию **стека** **вызовов**.

**Стек** – это структура данных **LIFO** (last in, first out): информация последовательно добавляется в «стопку» , каждый новый объект помещается поверх предыдущего, а извлекаются объекты в обратном порядке, – начиная с верхнего. Работу стека отлично иллюстрирует добавление данных в список с помощью `append` и извлечение информации посредством `pop`:

        `stack = [] for i in range(1, 11):     stack.append(f'{i}-й элемент')     print(f'+ {i}-й элемент добавлен')     for i in stack:         print(i, end=" ") print('\n')     for i in range(len(stack)):     print('В стеке: ', end=" ")     for i in stack:         print(i, end=" ")     print(f'\n{stack.pop()} удален из стека')`
    

Вывод:

        `+ 1-й элемент добавлен 1-й элемент + 2-й элемент добавлен 1-й элемент 2-й элемент + 3-й элемент добавлен 1-й элемент 2-й элемент 3-й элемент + 4-й элемент добавлен 1-й элемент 2-й элемент 3-й элемент 4-й элемент + 5-й элемент добавлен 1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент + 6-й элемент добавлен 1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент + 7-й элемент добавлен 1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент + 8-й элемент добавлен 1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 8-й элемент + 9-й элемент добавлен 1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 8-й элемент 9-й элемент + 10-й элемент добавлен 1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 8-й элемент 9-й элемент 10-й элемент   В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 8-й элемент 9-й элемент 10-й элемент  10-й элемент удален из стека В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 8-й элемент 9-й элемент  9-й элемент удален из стека В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 8-й элемент  8-й элемент удален из стека В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент  7-й элемент удален из стека В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент  6-й элемент удален из стека В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент  5-й элемент удален из стека В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент  4-й элемент удален из стека В стеке:  1-й элемент 2-й элемент 3-й элемент  3-й элемент удален из стека В стеке:  1-й элемент 2-й элемент  2-й элемент удален из стека В стеке:  1-й элемент  1-й элемент удален из стека`
    

**Стек вызовов**, в свою очередь, – это область памяти, в которой выполняются функции. При каждом вызове функции создается фрейм – фрагмент памяти, – в котором содержится:

- информация о текущем состоянии выполнения функции;
- значения всех переменных, которые функция получила для обработки;  
    
- локальные данные, созданные во время очередного вызова;  
    
- сведения о строке программы, к которой нужно вернуться после выполнения функции.  
    

Фреймы помещаются в стек вызовов, как уже было показано в примере выше, и удаляются точно так же, сверху вниз. Рекурсивные функции при каждом новом вызове используют данные, созданные во время работы предыдущего вызова.

Программисту не нужно беспокоиться о работе стека вызовов – созданием фреймов и управлением стеком занимается интерпретатор. Однако понимание принципа работы стека вызовов значительно упрощает создание рекурсивных функций. Неверное же использование рекурсии приводит к переполнению стека (**stack overflow**). Популярный сайт [StackOverflow](https://stackoverflow.com/) назван как раз в честь этой ошибки.

Переполнить стек в опытных целях можно с помощью простейшей рекурсивной функции, которая бесконечно вызывает сама себя, но не возвращает никаких данных и не содержит никакого условия для прекращения своей работы:

        `def recursive():     recursive()  recursive()`
    

Интерпретатор Python автоматически отслеживает переполнение стека и после 1000 бесплодных вызовов завершает работу подобных функций с ошибкой:

        `shortest() RecursionError: maximum recursion depth exceeded`
    

При желании лимит на глубину рекурсии можно увеличить, но сделать его бесконечным, разумеется, нельзя – даже самый внушительный объем оперативной памяти в итоге окажется переполненным:

        `from sys import getrecursionlimit from sys import setrecursionlimit print(getrecursionlimit()) # выводит лимит по умолчанию setrecursionlimit(2000) # увеличивает лимит до 2000 вызовов print(getrecursionlimit())# выводит новый лимит  #Вывод: 1000 2000`
    

Чтобы стек вызовов не переполнялся, в каждой рекурсивной функции всегда должны быть предусмотрены два случая:

1. **Граничный**, при котором функция завершает работу и возвращает данные в основную программу.  
    
2. **Рекурсивный**, при котором функция продолжает вызывать себя.  
    

Вот пример простейшей рекурсивной функции, в которой учтены оба случая:

        `def greetings(st):      print(st)      if len(st) == 0:  # Граничный случай          return                   else:       # Рекурсивный случай          greetings(st[:-1])     greetings('Hello, world!')`
    

Вызовы функции прекращаются, когда длина выводимой подстроки достигает **0**:

        `Hello, world! Hello, world Hello, worl Hello, wor Hello, wo Hello, w Hello,  Hello, Hello Hell Hel He H`
    

Эту же функцию можно переписать так, чтобы одно и то же условие проверяло и граничный, и рекурсивный случаи сразу:

        `def greetings(st):     print(st)     if len(st) > 0:           greetings(st[:-1])     greetings('Hello world!')`
    

И в первом, и во втором варианте рекурсивный случай многократно передает в функцию greetings() подстроку, длина которой уменьшается с каждым вызовом, пока не станет равной 0.

