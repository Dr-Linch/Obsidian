# Списки (list)

## Что такое списки?

Списки в Python - упорядоченные изменяемые коллекции объектов произвольных типов (почти как массив, но типы могут отличаться).

Чтобы использовать списки, их нужно создать. Создать список можно несколькими способами. Например, можно обработать любой итерируемый объект (например, [строку](https://pythonworld.ru/tipy-dannyx-v-python/stroki-literaly-strok.html)) встроенной функцией **list**:

>>>

>>> list('список')
['с', 'п', 'и', 'с', 'о', 'к']

Список можно создать и при помощи литерала:

>>>

>>> s = []  # Пустой список
>>> l = ['s', 'p', ['isok'], 2]
>>> s
[]
>>> l
['s', 'p', ['isok'], 2]

Как видно из примера, список может содержать любое количество любых объектов (в том числе и вложенные списки), или не содержать ничего.

И еще один способ создать список - это **генераторы списков**. Генератор списков - способ построить новый список, применяя выражение к каждому элементу последовательности. Генераторы списков очень похожи на цикл [for](https://pythonworld.ru/osnovy/cikly-for-i-while-operatory-break-i-continue-volshebnoe-slovo-else.html).

>>>

>>> c = [c * 3 for c in 'list']
>>> c
['lll', 'iii', 'sss', 'ttt']

Возможна и более сложная конструкция генератора списков:

>>>

>>> c = [c * 3 for c in 'list' if c != 'i']
>>> c
['lll', 'sss', 'ttt']
>>> c = [c + d for c in 'list' if c != 'i' for d in 'spam' if d != 'a']
>>> c
['ls', 'lp', 'lm', 'ss', 'sp', 'sm', 'ts', 'tp', 'tm']

Но в сложных случаях лучше пользоваться обычным циклом for для генерации списков.

## Функции и методы списков

Создать создали, теперь нужно со списком что-то делать. Для списков доступны основные [встроенные функции](https://pythonworld.ru/osnovy/vstroennye-funkcii.html), а также методы списков.

## Таблица "методы списков"

|Метод|Что делает|
|---|---|
|**list.append**(x)|Добавляет элемент в конец списка|
|**list.extend**(L)|Расширяет список list, добавляя в конец все элементы списка L|
|**list.insert**(i, x)|Вставляет на i-ый элемент значение x|
|**list.remove**(x)|Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует|
|**list.pop**([i])|Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент|
|**list.index**(x, [start [, end]])|Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end)|
|**list.count**(x)|Возвращает количество элементов со значением x|
|**list.sort**([key=функция])|Сортирует список на основе функции|
|**list.reverse**()|Разворачивает список|
|**list.copy**()|Поверхностная копия списка|
|**list.clear**()|Очищает список|

Нужно отметить, что методы списков, в отличие от [строковых методов](https://pythonworld.ru/tipy-dannyx-v-python/stroki-funkcii-i-metody-strok.html), изменяют сам список, а потому результат выполнения не нужно записывать в эту переменную.

>>>

>>> l = [1, 2, 3, 5, 7]
>>> l.sort()
>>> l
[1, 2, 3, 5, 7]
>>> l = l.sort()
>>> print(l)
None

И, напоследок, примеры работы со списками:

>>>

>>> a = [66.25, 333, 333, 1, 1234.5]
>>> print(a.count(333), a.count(66.25), a.count('x'))
2 1 0
>>> a.insert(2, -1)
>>> a.append(333)
>>> a
[66.25, 333, -1, 333, 1, 1234.5, 333]
>>> a.index(333)
1
>>> a.remove(333)
>>> a
[66.25, -1, 333, 1, 1234.5, 333]
>>> a.reverse()
>>> a
[333, 1234.5, 1, 333, -1, 66.25]
>>> a.sort()
>>> a
[-1, 1, 66.25, 333, 333, 1234.5]

# Массивы ( модуль array)

Модуль array определяет массивы в python. Массивы очень похожи на [списки](https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html), но с ограничением на тип данных и размер каждого элемента.

Размер и тип элемента в массиве определяется при его создании и может принимать следующие значения:

|Код типа|Тип в C|Тип в python|Минимальный размер в байтах|
|---|---|---|---|
|'b'|signed char|int|1|
|'B'|unsigned char|int|1|
|'h'|signed short|int|2|
|'H'|unsigned short|int|2|
|'i'|signed int|int|2|
|'I'|unsigned int|int|2|
|'l'|signed long|int|4|
|'L'|unsigned long|int|4|
|'q'|signed long long|int|8|
|'Q'|unsigned long long|int|8|
|'f'|float|float|4|
|'d'|double|float|8|

Класс **array.array**(TypeCode [, инициализатор]) - новый массив, элементы которого ограничены TypeCode, и инициализатор, который должен быть списком, объектом, который поддерживает интерфейс буфера, или итерируемый объект.

**array.typecodes** - строка, содержащая все возможные типы в массиве.

**Массивы изменяемы**. Массивы поддерживают все списковые методы (индексация, срезы, умножения, итерации), и другие методы.

## Методы массивов (array) в python

**array.typecode** - TypeCode символ, использованный при создании массива.

**array.itemsize** - размер в байтах одного элемента в массиве.

**array.append**(х) - добавление элемента в конец массива.

**array.buffer_info**() - кортеж (ячейка памяти, длина). Полезно для низкоуровневых операций.

**array.byteswap**() - изменить порядок следования байтов в каждом элементе массива. Полезно при чтении данных из файла, написанного на машине с другим порядком байтов.

**array.count**(х) - возвращает количество вхождений х в массив.

**array.extend**(iter) - добавление элементов из объекта в массив.

**array.frombytes**(b) - делает массив array из массива байт. Количество байт должно быть кратно размеру одного элемента в массиве.

**array.fromfile**(F, N) - читает N элементов из [файла](https://pythonworld.ru/tipy-dannyx-v-python/fajly-rabota-s-fajlami.html) и добавляет их в конец массива. Файл должен быть открыт на бинарное чтение. Если доступно меньше N элементов, генерируется [исключение](https://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html) EOFError , но элементы, которые были доступны, добавляются в массив.

**array.fromlist**(список) - добавление элементов из списка.

**array.index**(х) - номер первого вхождения x в массив.

**array.insert**(n, х) - включить новый пункт со значением х в массиве перед номером n. Отрицательные значения рассматриваются относительно конца массива.

**array.pop**(i) - удаляет i-ый элемент из массива и возвращает его. По умолчанию удаляется последний элемент.

**array.remove**(х) - удалить первое вхождение х из массива.

**array.reverse**() - обратный порядок элементов в массиве.

**array.tobytes**() - преобразование к байтам.

**array.tofile**(f) - запись массива в открытый файл.

**array.tolist**() - преобразование массива в список.

# Кортежи (tuple)

Кортеж, по сути - неизменяемый список.
## Зачем нужны кортежи, если есть списки?

- Защита от дурака. То есть кортеж защищен от изменений, как намеренных (что плохо), так и случайных (что хорошо).
- Меньший размер. Дабы не быть голословным:

> >>>
> 
> >>> a = (1, 2, 3, 4, 5, 6)
> >>> b = [1, 2, 3, 4, 5, 6]
> >>> a.__sizeof__()
> 36
> >>> b.__sizeof__()
> 44

- Возможность использовать кортежи в качестве ключей [словаря](https://pythonworld.ru/tipy-dannyx-v-python/slovari-dict-funkcii-i-metody-slovarej.html):

> >>>
> 
> >>> d = {(1, 1, 1) : 1}
> >>> d
> {(1, 1, 1): 1}
> >>> d = {[1, 1, 1] : 1}
> Traceback (most recent call last):
>   File "", line 1, in
>     d = {[1, 1, 1] : 1}
> TypeError: unhashable type: 'list'

## Как работать с кортежами?

С преимуществами кортежей разобрались, теперь встает вопрос - а как с ними работать. Примерно так же, как и со списками.

Создаем пустой кортеж:

>>>

>>> a = tuple() # С помощью встроенной функции tuple()
>>> a
()
>>> a = () # С помощью литерала кортежа
>>> a
()
>>>

Создаем кортеж из одного элемента:

>>>

>>> a = ('s')
>>> a
's'

Стоп. Получилась строка. Но как же так? Мы же кортеж хотели! Как же нам кортеж получить?

>>>

>>> a = ('s', )
>>> a
('s',)

Ура! Заработало! Все дело - в запятой. Сами по себе скобки ничего не значат, точнее, значат то, что внутри них находится одна инструкция, которая может быть отделена пробелами, переносом строк и прочим мусором. Кстати, кортеж можно создать и так:

>>>

>>> a = 's',
>>> a
('s',)

Но все же не увлекайтесь, и ставьте скобки, тем более, что бывают случаи, когда скобки необходимы.

Ну и создать кортеж из итерируемого объекта можно с помощью все той же пресловутой функции tuple()

>>>

>>> a = tuple('hello, world!')
>>> a
('h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!')

## Операции с кортежами

Все [операции над списками](https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html), не изменяющие список (сложение, умножение на число, методы index() и count() и некоторые другие операции). Можно также по-разному менять элементы местами и так далее.

Например, гордость программистов на python - поменять местами значения двух переменных:

a, b = b, a

# Словари (dict)

**Словари в Python** - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.

Чтобы работать со словарём, его нужно создать. Сделать это можно несколькими способами. Во-первых, с помощью литерала:

>>>

>>> d = {}
>>> d
{}
>>> d = {'dict': 1, 'dictionary': 2}
>>> d
{'dict': 1, 'dictionary': 2}

Во-вторых, с помощью функции **dict**:

>>>

>>> d = dict(short='dict', long='dictionary')
>>> d
{'short': 'dict', 'long': 'dictionary'}
>>> d = dict([(1, 1), (2, 4)])
>>> d
{1: 1, 2: 4}

В-третьих, с помощью метода fromkeys:

>>>

>>> d = dict.fromkeys(['a', 'b'])
>>> d
{'a': None, 'b': None}
>>> d = dict.fromkeys(['a', 'b'], 100)
>>> d
{'a': 100, 'b': 100}

В-четвертых, с помощью генераторов словарей, которые очень похожи на [генераторы списков](https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html).

>>>

>>> d = {a: a ** 2 for a in range(7)}
>>> d
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}

Теперь попробуем добавить записей в словарь и извлечь значения ключей:

>>>

>>> d = {1: 2, 2: 4, 3: 9}
>>> d[1]
2
>>> d[4] = 4 ** 2
>>> d
{1: 2, 2: 4, 3: 9, 4: 16}
>>> d['1']
Traceback (most recent call last):
  File "", line 1, in
    d['1']
KeyError: '1'

Как видно из примера, присвоение по новому ключу расширяет словарь, присвоение по существующему ключу перезаписывает его, а попытка извлечения несуществующего ключа порождает исключение. Для избежания исключения есть специальный метод (см. ниже), или можно [перехватывать исключение](https://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html).

Что же можно еще делать со словарями? Да то же самое, что и с другими объектами: [встроенные функции](https://pythonworld.ru/osnovy/vstroennye-funkcii.html), [ключевые слова](https://pythonworld.ru/osnovy/klyuchevye-slova-modul-keyword.html) (например, [циклы for и while](https://pythonworld.ru/osnovy/cikly-for-i-while-operatory-break-i-continue-volshebnoe-slovo-else.html)), а также специальные методы словарей.

## Методы словарей

**dict.clear**() - очищает словарь.

**dict.copy**() - возвращает копию словаря.

classmethod **dict.fromkeys**(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).

**dict.get**(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).

**dict.items**() - возвращает пары (ключ, значение).

**dict.keys**() - возвращает ключи в словаре.

**dict.pop**(key[, default]) - удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).

**dict.popitem**() - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.

**dict.setdefault**(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением default (по умолчанию None).

**dict.update**([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).

**dict.values**() - возвращает значения в словаре.

# Множества (set и frozenset)

## Что такое множество?

Множество в python - "контейнер", содержащий не повторяющиеся элементы в случайном порядке.

Создаём множества:

>>>

>>> a = set()
>>> a
set()
>>> a = set('hello')
>>> a
{'h', 'o', 'l', 'e'}
>>> a = {'a', 'b', 'c', 'd'}
>>> a
{'b', 'c', 'a', 'd'}
>>> a = {i ** 2 for i in range(10)} # генератор множеств
>>> a
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}
>>> a = {}  # А так нельзя!
>>> type(a)
<class 'dict'>

Как видно из примера, множества имеет тот же литерал, что и [словарь](https://pythonworld.ru/tipy-dannyx-v-python/slovari-dict-funkcii-i-metody-slovarej.html), но пустое множество с помощью литерала создать нельзя.

Множества удобно использовать для удаления повторяющихся элементов:

>>>

>>> words = ['hello', 'daddy', 'hello', 'mum']
>>> set(words)
{'hello', 'daddy', 'mum'}

С множествами можно выполнять множество операций: находить объединение, пересечение...

- len(s) - число элементов в множестве (размер множества).
- x in s - принадлежит ли x множеству s.
- **set.isdisjoint**(other) - истина, если set и other не имеют общих элементов.
- **set == other** - все элементы set принадлежат other, все элементы other принадлежат set.
- **set.issubset**(other) или **set <= other** - все элементы set принадлежат other.
- **set.issuperset**(other) или **set >= other** - аналогично.
- **set.union**(other, ...) или **set | other | ...** - объединение нескольких множеств.
- **set.intersection**(other, ...) или **set & other & ...** - пересечение.
- **set.difference**(other, ...) или **set - other - ...** - множество из всех элементов set, не принадлежащие ни одному из other.
- **set.symmetric_difference**(other); **set ^ other** - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
- **set.copy**() - копия множества.

И операции, непосредственно изменяющие множество:

- **set.update**(other, ...); set |= other | ... - объединение.
- **set.intersection_update**(other, ...); set &= other & ... - пересечение.
- **set.difference_update**(other, ...); set -= other | ... - вычитание.
- **set.symmetric_difference_update**(other); set ^= other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
- **set.add**(elem) - добавляет элемент в множество.
- **set.remove**(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.
- **set.discard**(elem) - удаляет элемент, если он находится в множестве.
- **set.pop**() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
- **set.clear**() - очистка множества.

## frozenset

Единственное отличие set от frozenset заключается в том, что set - изменяемый тип данных, а frozenset - нет. Примерно похожая ситуация с [списками](https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html) и [кортежами](https://pythonworld.ru/tipy-dannyx-v-python/kortezhi-tuple.html).

>>>

>>> a = set('qwerty')
>>> b = frozenset('qwerty')
>>> a == b
True
>>> True
True
>>> type(a - b)
<class 'set'>
>>> type(a | b)
<class 'set'>
>>> a.add(1)
>>> b.add(1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'frozenset' object has no attribute 'add'