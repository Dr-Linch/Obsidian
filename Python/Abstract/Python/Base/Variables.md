## Как работают переменные в python

>Переменная — это именованная область памяти. После того как вы дали имя области, появляется возможность обращаться к данным, что в ней хранятся.

Каждый элемент данных в Python является объектом определенного типа или класса. Когда, в процессе выполнения программного кода, появляется новое значение, интерпретатор выделяет для него область памяти — то есть создаёт объект определенного типа (число, строка и т.д.). После этого Python записывает в свой внутренний список адрес этого объекта.

Для этого и существуют переменные — они дают возможность удобно работать с объектами используя имена вместо адресов.

Простыми словами переменная в Python — это просто имя, прикрепленное к определенному объекту

Чтобы создать новую переменную в Python, ее нужно заранее инициализировать.

>Инициализация переменной — это присвоение ей начального значения.

Для инициализации достаточно придумать переменной имя и присвоить значение через оператор `=`.

Переменная (имя переменной) > адрес в памяти > значение

## Переменные, объекты и ссылки

После инициализации переменной происходит следующее:
1. создается объект типа `int` со значением `100`;
2. создается переменная `a`;
3. в переменной `a` сохранится адрес (ссылка) на объект;

Важно: переменная в Python не хранит значение напрямую — она хранит лишь ссылку на объект

Если присвоить переменную другой переменной то они будут ссылаться на один объект в памяти компьютера.
a = b

Если изменить значение для переменной b то будет создан новый объект с новым типом и значением.

a = b
b = 100

Если мы снова изменим значение для переменной b то на объект с типом int и значением 100 никто не будет ссылаться, следовательно он станет недоступным и будет удалён сборщиком мусора.

## Идентификатор объекта (Object Identity)

>Идентификатор объекта — это адрес объекта в памяти.

Что-бы узнать адрес объекта можно воспользоваться функцией id() она вернёт число которое является уникальным и неизменным для каждого объекта на протяжении его жизненного цикла.

```python
a = b = 1

print(id(a))
> 1593636784

print(id(b))
> 1593636784

print(id(1))
> 1593636784
```

Видно, что объект здесь всего один. А `a` и `b` — по-разному названные переменные, которые на него ссылаются. Проверить равенство идентификаторов можно с помощью оператора `is`:

```python
print(a is b)
> True
```

## Работа с переменными

В языке Python имя переменной должно состоять только из цифр, букв и знаков подчеркивания. И не должно начинаться с цифры.

Это жёсткий внутренний закон языка, помимо которого есть свод более мягких, но не менее важных правил, и они говорят нам:

- давайте переменным имена, которые описывают суть объекта;
- используйте единый стиль именования в рамках каждого проекта;
- старайтесь не создавать наименования длиннее пятнадцати символов;

В каждом языке есть зарезервированные слова. Такие слова имеют специальное значение, и поэтому запрещены для использования в качестве имён переменных.

### Как объявить переменную

> Для присваивания в python используется знак "=". 

В Питоне не требуется специального объявления переменных. В момент присваивания значения, объявление происходит автоматически. А присваивание выглядит так:

```python
sitename = "Pythonchik"
```

### Проверка существования переменной

Чтобы выяснить, есть ли в программе переменная (например `cat`), ищем вхождение строки с её названием в словарях, возвращаемых функциями `locals()` (локальная видимость) и `globals()` (глобальная видимость):

```python
if "cat" in locals():
    # …

if "cat" in globals():
    # …
```

### Удаление переменной

Переменная удаляется, если передать её в качестве аргумента во встроенную функцию `del()`:

```python
please_dont = 'alive'
del(please_dont)

print(please_dont)
> 
Traceback (most recent call last):
 print(please_dont)
NameError: name 'please_dont' is not defined
```

### Что означает звездочка перед переменной?

Символ `*` перед именем переменной может означать несколько вещей.

1. Распаковывает итерируемый объект в аргументы функции.

```python
status = ['open', 'close']
print(status)
> ['open', 'close']

print(*status)
> open close
```

2. Позволяет передавать в функцию переменное количество аргументов, запаковывая их в кортеж.

```python
def summer(*terms):
    sum = 0
    for term in terms:
        sum = sum + term
    return sum

print(summer(2))
> 2

print(summer(3, 3))
> 6

print(summer(4, 43, 1))
> 48
```

3. Позволяет вложить итерируемый объект в новую коллекцию.

```python
def setCreator(some_list):
    return {*some_list[1:]}

weapons = ['bow', 'pike', 'sword', 'dagger']

print(setCreator(weapons))
> {'dagger', 'pike', 'sword'}

print(type(setCreator(weapons)))
> <class 'set'>
```

## Область видимости: локальные и глобальные переменные

> Область видимости или пространство имен — это место в программном коде, где переменной было присвоено значение.

Существуют три разные области видимости:

1 Локальная. Если переменная была инициализирована внутри `def`, то она локальная.

```python
def localExample():
    # x - локальная внутри localExample()
    x = 5
```

2 Нелокальная. Если внутри функции определена другая функция, то переменная внутри внешнего `def` будет нелокальной для `def` внутреннего. То есть сделать вот так не получится:

```python
def nonlocalExample():
    # x - локальная внутри nonlocalExample()
    x = 5
    def innerFunc():
        x = x + 1
        return x
    return innerFunc()

print(nonlocalExample())

> UnboundLocalError: local variable 'x' referenced before assignment
```

Поэтому для корректной работы нужно использовать ключевое слово `nonlocal`:

```python
def nonlocalExample():
    # x - локальная внутри nonlocalExample()
    x = 5

    def innerFunc():
        nonlocal x
        x = x + 1
        return x

    return innerFunc()


print(nonlocalExample())
> 6
```

3 Глобальная. Переменная глобальна, если её присваивание производится за пределами всех `def`.

```python
num = 42


def globalExample(n):
    res = n + num
    return res


print(globalExample(1))
> 43
```

## Статические переменные

> Статическая переменная сохраняет свое значение между вызовами функций.

Звучит очень похоже на определение глобальной переменной, однако в том-то и дело, что статическая переменная может быть и локальной.

Самих по себе статических переменных в Питоне нет

Но их можно реализовать с помощью классов:

```python
# сделаем питоновский аналог статической переменной
class staticVar:
    i = 3


def incrementer():
    staticVar.i = staticVar.i + 1


incrementer()
incrementer()

print(staticVar.i)
# Видно, что значение между вызовами функции сохраняется
> 5
```