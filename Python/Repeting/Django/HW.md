# Lesson #1
### Task #1
Для начала работы над задачей выполните первые шаги:
 - Настройте виртуальное окружение.
 - Создайте новый Django-проект.

### Task #2
После успешного создания проекта сделайте первую настройку. Для этого:

-  Создайте первое приложение с названием catalog
-  Внесите начальные настройки проекта.
-  Сделайте настройку урлов (URL-файлов) для нового приложения.

### Task #3
Подготовьте два шаблона для домашней страницы и страницы с контактной информацией.

>Для создания шаблонов лучше использовать UIkit Bootstrap. Это удобный набор элементов, которые уже стилизованы и готовы к использованию. UIkit Bootstrap помогает избежать самостоятельной верстки макетов.

### Task #4
В приложении в контроллере реализуйте два контроллера:

1.  Контроллер, который отвечает за отображение домашней страницы.
2.  Контроллер, который отвечает за отображение контактной информации.

### * Task #5
Реализуйте обработку сбора обратной связи от пользователя, который зашел на страницу контактов и отправил свои данные для обратной связи.

# Lesson #2

### Task #1
Подключите СУБД PostgreSQL для работы в проекте, для этого:

1. Создайте базу данных в ручном режиме.
2. Внесите изменения в настройки подключения.

### Task #2
В приложении каталога создайте модели:

- Product,
- Category.

Опишите для них начальные настройки.

>К начальным настройкам модели относятся метод ""\_\_str\_\_"" и ""class Meta"" с описанием свойств модели.
### Task #3
Для каждой модели опишите следующие поля:

1. Product
- Наименование
- Описание
- Изображение (превью)
- Категория
- Цена за покупку
- Дата создания (записи в БД)
- Дата последнего изменения (записи в БД)

2. Category
- Наименование
- Описание

>Свяжите продукт и категорию, используя связь между таблицами «Один ко многим».
У одной категории может быть много продуктов, но у одного продукта может быть только одна категория.
Воспользуйтесь специальным полем модели — ForeignKey().
При необходимости подробнее про то, как работает такое поле, можно почитать [тут](https://metanit.com/python/django/5.6.php).
Поля «Дата создания» и «Дата последнего изменения» стали стандартом для моделей. Их общепринятые названия — created_at и updated_at соответственно.


>**Примечание**
Для поля с изображением необходимо добавить соответствующие настройки (MEDIA URL, MEDIA ROOT, настроить URL для отображения медиаданных) в проект, а также установить библиотеку для работы с изображениями ""Pillow"".
Не забудьте обновить файл с зависимостями для проекта после установки новой библиотеки.


### Task #4
Перенесите отображение моделей в базу данных с помощью инструмента миграций, для этого:

- создайте миграции для новых моделей;
- примените миграции;
- внесите изменения в модель продукта, добавьте поле «Дата производства продукта» (manufactured_at), примените обновление структуры с помощью миграций;
- откатите миграцию до состояния, когда поле «Дата производства продукта» (manufactured_at) для модели продукта еще не существовало, и удалите лишнюю миграцию.

>Важно сохранять всю историю миграций проекта для сохранения целостности базы данных проекта.
Не забудьте добавить все выполненные миграции в коммит, а затем отправить в удаленный репозиторий на GitHub.

### Task #5
Для моделей категории и продукта настройте отображение в административной панели. Для категорий выведите id и наименование в список отображения, а для продуктов выведите в список id, название, цену и категорию.

При этом интерфейс вывода продуктов настройте так, чтобы можно было результат отображения фильтровать по категории, а также осуществлять поиск по названию и полю описания.

### Task #6
1. Через инструмент shell заполните список категорий, а также выберите список категорий, применив произвольные рассмотренные фильтры. В качестве решения приложите скриншот.

> Установите библиотеку ipython для комфортной работы с инструментом 
> shell. Не забудьте зафиксировать изменения в файле зависимостей проекта.

2. Сформируйте фикстуры для заполнения базы данных.

> Фикстуры создайте командой. Для управления кодировкой используйте опцию -Xutf8
 для команды. Такой параметр уместно будет использовать на операционной системе Windows.

3. Напишите кастомную команду, которая умеет заполнять данные в базу данных, при этом предварительно ее зачищать от старых данных.

### \* Task #7
- В контроллер отображения главной страницы добавить выборку последних пяти товаров и вывод их в консоль.
- Создать модель для хранения контактных данных и попробовать вывести данные, заполненные через админку, на страницу с контактами.

# Lesson #3

### Task #1
Создайте новый контроллер и шаблон, которые будут отвечать за отображение отдельной страницы с товаром, на которой необходимо вывести всю информацию о самом товаре.

### Task #2
В созданный ранее шаблон для главной страницы выведите список товаров в цикле. Для единообразия выводимых карточек отображаемое описание необходимо обрезать после первых выведенных 100 символов.
### Task #3
Из-за расширения количества шаблонов появляется слишком много повторяющегося кода, поэтому выделите общий (базовый) шаблон, а также подшаблон с главным меню.

>В подшаблон вынесите общие для всех кодовые части (HTML-код). Не забудьте разместить блок с контентом, куда будут вставляться шаблоны, которые используют подшаблон:
{% block content %}
{% endblock %}
И подключите их к другим шаблонам с помощью
{% extends 'путь к базовому шаблону' %}
Код расширенного шаблона разместите внутри блока с контентом.


>**Примечание**
При необходимости можно выделить больше общих шаблонов.


### Task #4
Для выводимого изображения на странице реализуйте шаблонный фильтр или шаблонный тег, который преобразует переданный путь в полный путь для доступа к медиафайлу.

### \* Task #5
-  Добавьте функционал создания продукта через внешний интерфейс, созданный вручную.
- Реализуйте постраничный вывод списка продуктов.

# Lesson #4

### Task #1
Продолжаем работать с проектом из предыдущего домашнего задания. Переведите имеющиеся контроллеры с FBV на CBV.
### Task #2
Создайте новую модель блоговой записи со следующими полями:

- заголовок,
- slug (реализовать через CharField),
- содержимое,
- превью (изображение),
- дата создания,
- признак публикации,
- количество просмотров.

Для работы с блогом реализуйте CRUD для новой модели.

> Slug — человекопонятный URL, представляет собой набор символов, которые можно прочитать как связные слова или предложения в адресной строке, служит уникальным идентификатором записи в рамках одной модели и состоит из безопасных для обработки запроса символов:

>- 0-9
>-  a-z (обычно в нижнем регистре),
>- символ -

### Task #3
Модифицируйте вывод и обработку запросов, добавив следующую логику на уровне контроллеров:

- при открытии отдельной статьи увеличивать счетчик просмотров;
- выводить в список статей только те, которые имеют положительный признак публикации;
- при создании динамически формировать slug name для заголовка;
- после успешного редактирования записи необходимо перенаправлять пользователя на просмотр этой статьи.

### \* Task #4
Когда статья достигает 100 просмотров, отправлять себе на почту поздравление с достижением.

# Lesson #5

### Task #1
Продолжаем работать с проектом из предыдущего домашнего задания. Для модели продуктов реализуйте механизм CRUD, задействовав модуль 

```
django.forms
```
.

Условия для пользователей:

-  могут создавать новые продукты;
-  не могут загружать запрещенные продукты на платформу.

Для исключения загрузки запрещенных продуктов реализуйте валидацию названия и описания продукта таким образом, чтобы нельзя было в них добавлять слова: казино, криптовалюта, крипта, биржа, дешево, бесплатно, обман, полиция, радар.

### Task #2
Добавьте новую модель «Версия», которая должна содержать следующие поля:

- продукт,
- номер версии,
- название версии,
- признак текущей версии.

При наличии активной версии реализуйте вывод в список продуктов информации об активной версии.

### Task #3
Для работы с версиями продукта добавьте реализацию работы с формами. При этом версия может быть внесена только в существующий продукт.

>	Все созданные формы нужно стилизовать так, чтобы они были в единой стилистике оформления всей платформы. Для этого можно воспользоваться методом 
	 ```
	__init__
	 ```
	 либо самостоятельно изучить пакет crispy-forms: [https://pypi.org/project/django-crispy-forms/](https://pypi.org/project/django-crispy-forms/).

### \* Task #4
В один момент времени может быть только одна активная версия продукта, поэтому при изменении версий необходимо проверять, что пользователь в качестве активной версии указал только одну. В случае возникновения ошибки вернуть сообщение пользователю и попросить выбрать только одну активную версию.

# Lesson #6

### Task #1
Создайте новое приложение для работы с пользователем. Определите собственную форму для пользователя, при этом задайте электронную почту как поле для авторизации.

Также добавьте поля:

- «Аватар»,
- «Номер телефона»,
- «Страна».

### Task #2
В сервисе реализуйте функционал аутентификации, а именно:

- регистрацию пользователя по почте и паролю;
- верификацию почты пользователя через отправленное письмо;
- авторизацию пользователя;
- восстановление пользователя на автоматически сгенерированный пароль.

### Task #3
Закройте для анонимных пользователей все контроллеры, которые отвечают за работу с продуктами. При этом создаваемые продукты должны автоматически привязываться к авторизованному пользователю.

>Не забудьте добавить поле для продуктов, через которое пользователь будет привязываться. Текущий авторизованный пользователь доступен в любом контроллере через 
```
self.request.user
```
.

### \* Task #4
Добавьте интерфейс редактирования профиля пользователя.

# Lesson #7

### Task #1
Продолжаем работать с проектом. Создайте группу для роли модератора и опишите необходимые доступы:

-  может отменять публикацию продукта,
-  может менять описание любого продукта,
-  может менять категорию любого продукта.

>	Недостающее поле признака публикации необходимо добавить таким образом, чтобы можно было определять статус продукта. Можно использовать 
```
BooleanField
```
 со значением 
```
False
```
 по умолчанию или 
```
CharField
```
 с указанием вариантов значений (choises). При этом по умолчанию должен быть вариант, который не предполагает публикацию продукта.

### Task #2
Реализуйте решение, которое проверит, что редактирование продукта доступно только его владельцу.

### \* Task #3
Выделите отдельную роль для пользователя контент-менеджера, который может управлять публикациями в блоге. Также не забудьте реализовать проверки на то, что обычный пользователь или модератор из другого отдела не сможет ничего изменить в разделе блога.

# Lesson #8

### Task #1
Продолжаем работать с проектом. Установите брокер для кеширования Redis. Внесите необходимые настройки и проверьте работоспособность проекта с новыми настройками.

### Task #2
Настройте кеширование всего контроллера отображения данных относительно одного продукта.

>	Помните, что кеширование можно подключать не только в файле views.py, но и в файле маршрутизации urls.py. Важно делать всё в одном месте, чтобы достичь единообразия в коде проекта и не запутаться впоследствии.

### Task #3
Создайте сервисную функцию, которая будет отвечать за выборку категорий и которую можно переиспользовать в любом месте системы. Добавьте низкоуровневое кеширование для списка категорий.

### Task #4
Вынесите необходимые настройки в переменные окружения и настройте проект для работы с ними.

### \* Task #5
Добавьте кеширование всего сайта целиком, при этом отключите от кеширования определенные контроллеры, которые отвечают за работу по заполнению продуктов и блога.
