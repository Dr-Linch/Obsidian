### `1. all(iterable)`

Функция `all()` в Python принимает в качестве параметра любой итерабельный объект: список, кортеж, множество словарь или диапазон. Данная функция возвращает `True`, если все элементы итерируемого объекта равняются `True`, а в противном случае  —  `False`. Любой числовой тип данных, кроме нуля, равняется `True`, а любая строка, содержащая более одного символа, также равняется `True`. Ознакомьтесь с несколькими примерами применения функции `all()`:

```
all([True, True, True]) # Trueall([True, True, 0]) # Falseall(("", True, 5)) # Falseall((True, 1.75, "Hello")) # Trueall({False, "World", True}) # Falseall({"Hi", -0.5, True}) # Trueall({0: "Hello", 1: "World"}) # Falseall({"Hello World": -1.75, 5: 6}) # True
```

---

### 2. any(iterable)

Функция `any()` в Python очень похожа на функцию `all()`. Она также принимает в качестве параметра итерабельный объект, но возвращает `True`, если хотя бы один из элементов итерабельного объекта равен `True`, в противном случае  —  `False`. Для различных типов данных действуют одни и те же правила оценки объекта как равного `True` или `False`. Вот несколько примеров, демонстрирующих применение функции `any()`:
```
any([False, False, False]) # Falseany([7.5, False, 0]) # Trueany(("", 0, "Hi")) # Trueany((0, '', "")) # Falseany({0, "World", False}) # Trueany({'', -0.5, 0}) # Trueany({'': False, 1.5: False}) # Trueany({"": True, False: 6}) # False
```

---

### 3. zip (interable1, interable2, interable3, …)

Функция `zip()` принимает любое количество итерабельных объектов. Помните, что итерабельный объект  —  это любая коллекция, такая как список, кортеж, множество словарь или диапазон. Снова обратите внимание, что при обработке словаря функция просматривает только ключ, но не значения. 

Функция `zip()` попарно объединяет элементы переданных коллекций по их индексу и возвращает специальный объект `zip`, который можно преобразовать в список или кортеж, состоящий из кортежей. Функция `zip()` обычно применяется для одновременного перебора нескольких списков.

```
names = ["Johnny", "Adam", "Mark"]ages = [14, 16, 17]people = list(zip(names, ages))print(people)# [('Johnny', 14), ('Adam', 16), ('Mark', 17)]
```

Объект `zip` можно обойти в цикле следующим образом:

```
names = ["Johnny", "Adam", "Mark"]ages = [14, 16, 17]for name, age in zip(names, ages):    print(name, age)
```

---

### 4. enumerate (iterable, start=0)

Функция `enumerate()` чаще всего применяется для циклического просмотра списка. После передачи итерабельного объекта в качестве параметра функция возвращает список из кортежей, где каждый кортеж содержит индекс элемента и сам элемент. Функция возвращает специальный объект `enumerate`, поэтому впоследствии вам придется все так же преобразовать его в список или кортеж. 

```
names = ["Johnny", "Adam", "Mark"]enum_names = list(enumerate(names))print(enum_names)# [(0, 'Johnny'), (1, 'Adam'), (2, 'Mark')]
```

Параметр `start` указывает функции `enumerate()`, с какого числа начинать отсчет индексов.

```
names = ["Johnny", "Adam", "Mark"]enum_names = list(enumerate(names, start=2))print(enum_names)# [(2, 'Johnny'), (3, 'Adam'), (4, 'Mark')]
```

Объект `enumerate` можно обойти в цикле следующим образом:

```
names = ["Johnny", "Adam", "Mark"]for i, name in enumerate(name):    print(i, name)
```

---

### 5. filter (function, iterable)

Функция `filter()` применяется для простой фильтрации итерабельного объекта без необходимости создания собственного цикла или дополнительных переменных. Все, что вам потребуется,  — это функция `filter()`, возвращающая либо `True`, либо `False`, в зависимости от условия. Если функция возвращает `False`, то элемент будет удален из итерабельного объекта, если `True`  —  останется. Как и другие функции, рассмотренные нами до сих пор, функция `filter()` также возвращает специальный объект `filter`, который затем преобразовывается в список или кортеж. Пример поможет понять, как применяется фильтрация:

```
people = [    ('Johnny', 22),    ('Adam', 18),    ('Mark', 12),    ('Jack', 14),    ('Sam', 20)]def is_adult(person): # person --> (name, age)    return person[1] >= 18adults = filter(is_adult, people)print(list(adults))# [('Johnny', 22), ('Adam', 18), ('Sam', 20)]
```

При желании напишите лямбда-выражение вместо функции, выступающей в качестве условия для фильтрации итерабельного объекта.

```
is_adult = lambda person: person[1] >= 18adults = filter(is_adult, people)print(list(adults))#[('Johnny', 22), ('Adam', 18), ('Sam', 20)]
```

---

### 6. map (function, iterable)

Функция `map()`  —  еще одна полезная встроенная функция, обрабатывающая итерабельные объекты. Подобно функции `filter()`, `map()` также принимает еще одну функцию, с помощью которой перебираются все элементы по очереди. Как и остальные пять рассмотренных нами функций, функция `map()` возвращает специальный объект `map`, в дальнейшем преобразовываемый в список или кортеж. Вот несколько примеров, показывающих, как применить функцию `map()` на практике:

```
def times_10(num):    return num * 10nums = [1, 2, 3, 4, 5]nums = list(map(times_10, nums))print(nums)# [10, 20, 30, 40, 50]
```

Как и ранее, вместо функции можно написать лямбда-выражение.

```
times_10 = lambda num: num * 10
```

Рассмотрите внимательно пример перебора функцией `map` нескольких итерабельных объектов:

```
def add(n1, n2, n3):    return n1 + n2 + n3nums1 = [1, 3, 5, 7, 9]nums2 = [2, 4, 6, 8, 10]nums3 = [11, 12, 13, 14, 15]sums = list(map(add, nums1, nums2, nums3))print(sums)# [14, 19, 24, 29, 34]
```

В примере функция `map()` возвращает список с суммами чисел из разных коллекций по общим индексам.

## 7. reduce(function, iterable)

В Python 3.X функция `reduce()` не является встроенной, а расположена в модуле `functools`. Выглядит она сложнее предыдущих двух, поэтому давайте разбираться. Она принимает итерируемый объект, а возвращает одиночный результат. Взглянем на синтаксис:

Пример (python)

```python
reduce(func, iterable[, initial]) 
```

Скопировать

Параметр `func` – функция, к которой кумулятивно применяется каждый элемент `iterable`. Значение `initial` является необязательным и в случае указания, служит стартовым значением или значением по умолчанию, если итерируемый объект пуст.

Функция `func` требует два аргумента (или один, если указан `initial`). Разберем на примере. Напишем программу, которая считает сумму чисел в списке.

Пример (python)

```python
from functools import reduce

numbers = [1, 2, 3, 4, 5, 6]
result = reduce(lambda x, y : x + y, numbers)
print(result) # => 21 
```

Скопировать

Не забываем подключить модуль `functools` и импортировать из нее `reduce()`. Думаю, очевидно, что произойдет, если в параметр `initial` передать число `10`.

Пример (python)

```python
from functools import reduce

numbers = [1, 2, 3, 4, 5, 6]
result = reduce(lambda x, y : x + y, numbers, 10)
print(result) # => 31 
```